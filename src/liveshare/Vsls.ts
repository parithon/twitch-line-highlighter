import { Disposable } from "vscode";
import {
  LiveShare,
  SharedService,
  SharedServiceProxy
} from "vsls";

import {
  HighlighterAPI,
  IHighlightRequested,
  IUnhighlightRequested,
  IUnhighlightAllRequested
} from "../api";

export class Vsls implements Disposable {
  static ServiceId = 'proxy';
  static highlightNotification: 'highlight';
  static unhighlightNotification: 'unhighlight';
  static unhighlightAllNotification: 'unhighlightAll';

  /**
   * Create a new VSLS shared service used to notify VSLS guests about
   * changes in our highlights
   * @param vsls The live share API
   * @param api The Highlighter API
   */
  static async share(vsls: LiveShare, api: HighlighterAPI) {
    const service = await vsls.shareService(this.ServiceId);
    if (service === null) {
      throw new Error('Failed to share host service.');
    }
    return new Vsls(vsls, service, api);
  }

  /**
   * Retrieve a VSLS shared service generated by the host to keep
   * track of our highlights
   * @param vsls The live share API
   * @param api The Highlighter API
   */
  static async connect(vsls: LiveShare, api: HighlighterAPI) {
    const service = await vsls.getSharedService(this.ServiceId);
    if (service === null) {
      throw new Error('Failed to connect to host service.');
    }
    return new Vsls(vsls, service, api);
  }

  private readonly _disposable: Disposable;
  private readonly _vsls: LiveShare;
  private readonly _service: SharedService | SharedServiceProxy;
  private readonly _api: HighlighterAPI;

  constructor(vsls: LiveShare, service: SharedService | SharedServiceProxy, api: HighlighterAPI) {
    this._vsls = vsls;
    this._service = service;
    this._api = api;

    this._service.onNotify(Vsls.highlightNotification, this.onHighlightRequestHandler.bind(this));
    this._service.onNotify(Vsls.unhighlightNotification, this.onUnhighlightRequestHandler.bind(this));
    this._service.onNotify(Vsls.unhighlightAllNotification, this.onUnhighlightAllRequestHandler.bind(this));

    this._disposable = Disposable.from(
      this._api.onHighlightRequested(this.onHighlightRequestedHandler, this),
      this._api.onUnhighlightRequested(this.onUnhighlightRequestedHandler, this),
      this._api.onUnhighlightAllRequested(this.onUnhighlightAllRequested, this),
    );
  }

  public dispose() {
    this._disposable.dispose();
    this._vsls.unshareService(Vsls.ServiceId);
  }

  private onHighlightRequestHandler(args: any) {
    const { service, userName, startLine, endLine, comments } = args;
    this._api.requestHighlight(service, userName, startLine, endLine, comments, this._vsls.session.id || undefined);
  }

  private onUnhighlightRequestHandler(args: any) {
    const { service, userName, lineNumber } = args;
    this._api.requestUnhighlight(service, userName, lineNumber, this._vsls.session.id || undefined);
  }

  private onUnhighlightAllRequestHandler(args: any) {
    const { service } = args;
    this._api.requestUnhighlightAll(service, this._vsls.session.id || undefined);
  }

  private isRequestFromMe(id?: string): boolean {
    return id === this._vsls.session.id;
  }

  private onHighlightRequestedHandler(e: IHighlightRequested) {
    if (!this.isRequestFromMe(e.callerId) && this._service.isServiceAvailable) {
      this._service.notify(Vsls.highlightNotification, e);
    }
  }

  private onUnhighlightRequestedHandler(e: IUnhighlightRequested) {
    if (!this.isRequestFromMe(e.callerId) && this._service.isServiceAvailable) {
      this._service.notify(Vsls.unhighlightNotification, e);
    }
  }

  private onUnhighlightAllRequested(e: IUnhighlightAllRequested) {
    if (!this.isRequestFromMe(e.callerId) && this._service.isServiceAvailable) {
      this._service.notify(Vsls.unhighlightAllNotification, e);
    }
  }
}
